# Example 4
data "aws_region" "current" {}

#####################################################################################
# Used in both examples
#####################################################################################
data "aws_availability_zones" "available" {}

resource "random_string" "suffix" {
  length  = 8
  special = false
}
#####################################################################################

#####################################################################################
# Same in both examples
#####################################################################################
#Network (All of the following are related to AWS EKS Networking)
resource "aws_vpc" "eks_vpc" {
  cidr_block = "10.0.0.0/16"

  tags = {
    Name = "eks-vpc-example-4-${random_string.suffix.result}"
  }
}
#####################################################################################

resource "aws_subnet" "public_eks_subnet" {
  count                   = 2
  vpc_id                  = aws_vpc.eks_vpc.id
  cidr_block              = cidrsubnet(aws_vpc.eks_vpc.cidr_block, 8, count.index)
  availability_zone       = data.aws_availability_zones.available.names[count.index]
  map_public_ip_on_launch = true

  tags = {
    Name = "eks-public-subnet-example-4-${count.index}"
  }

  # depends_on = [aws_vpc.eks_vpc]
}

# No private subnet declared

#####################################################################################
# Same in both examples
#####################################################################################
resource "aws_internet_gateway" "igw" {
  vpc_id = aws_vpc.eks_vpc.id

  tags = {
    Name = "my-eks-cluster-example-4-${random_string.suffix.result}"
  }

  # depends_on = [aws_vpc.eks_vpc]
}

resource "aws_route_table" "public" {
  vpc_id = aws_vpc.eks_vpc.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.igw.id
  }

  tags = {
    Name = "my-eks-cluster-public-route-table-example-4-${random_string.suffix.result}"
  }

  # depends_on = [aws_vpc.eks_vpc, aws_internet_gateway.igw]
}
#####################################################################################

# No private route table

resource "aws_route_table_association" "public" {
  count          = 2
  subnet_id      = aws_subnet.public_eks_subnet.*.id[count.index]
  route_table_id = aws_route_table.public.id

  # depends_on = [aws_route_table.public, aws_vpc.eks_vpc, aws_internet_gateway.igw]
}

# No private route association

#####################################################################################
# Uses module to instantiate EKS
#####################################################################################
module "eks" {
  depends_on = [aws_route_table_association.public]
  source  = "terraform-aws-modules/eks/aws"
  version = "~> 20.31"

  cluster_name    = "example-4-${random_string.suffix.result}"
  cluster_version = "1.33"

  # Optional
  cluster_endpoint_public_access = true

  # Optional: Adds the current caller identity as an administrator via cluster access entry
  enable_cluster_creator_admin_permissions = true

  eks_managed_node_groups = {
    example = {
      instance_types = ["t3.small"]
      min_size       = 1
      max_size       = 3
      desired_size   = 2
    }
  }

  vpc_id     = aws_vpc.eks_vpc.id
  subnet_ids = aws_subnet.public_eks_subnet.*.id

  tags = {
    Environment = "dev"
    Terraform   = "true"
  }
}

data "aws_eks_cluster" "eks_cluster" {
  depends_on = [
    module.eks
  ]
  # name = aws_eks_cluster.eks_cluster.name
  name = module.eks.cluster_name
}

data "aws_eks_cluster_auth" "eks_cluster" {
  depends_on = [
    module.eks
  ]
  # name = aws_eks_cluster.eks_cluster.name
  name = module.eks.cluster_name
}
#####################################################################################
# End EKS Configuration
#####################################################################################

#####################################################################################
# ALL CONFIGURATION BELOW HERE IS FOR THE IMAGE "DEPLOYED TO" EKS AND NOT EKS ITSELF
#####################################################################################

########################################################################################################################
# Deploy the application to the EKS Cluster - This is essentially the same between Tutorial 1 and 2
########################################################################################################################
# Kubernetes provider for Terraform to connect with AWS EKS Cluster
provider "kubernetes" {
  host                   = data.aws_eks_cluster.eks_cluster.endpoint
  token                  = data.aws_eks_cluster_auth.eks_cluster.token
  cluster_ca_certificate = base64decode(data.aws_eks_cluster.eks_cluster.certificate_authority[0].data)
}

#Kubernetes resources in Terraform
resource "kubernetes_namespace" "terraform-k8s" {
  metadata {
    name = "terraform-k8s"
  }
}

resource "kubernetes_deployment" "sb_aws_eks" {
  depends_on = [module.eks]
  metadata {
    name      = "spring-boot-with-aws-eks-and-terraform"
    namespace = kubernetes_namespace.terraform-k8s.metadata[0].name
  }

  spec {
    replicas = 1

    selector {
      match_labels = {
        app = "spring-boot-with-aws-eks-and-terraform"
      }
    }

    template {
      metadata {
        labels = {
          app = "spring-boot-with-aws-eks-and-terraform"
        }
      }

      spec {
        container {
          name  = "spring-boot-with-aws-eks-and-terraform"
          image = "rhineb/spring-boot-with-aws-eks-and-terraform:latest"
          # image_pull_policy = "IfNotPresent"

          port {
            container_port = 8080
          }
        }
      }
    }
  }
}

resource "kubernetes_service" "sb_aws_eks" {
  depends_on = [module.eks]
  metadata {
    name      = "spring-boot-with-aws-eks-and-terraform"
    namespace = kubernetes_namespace.terraform-k8s.metadata[0].name
  }

  spec {
    selector = {
      app = kubernetes_deployment.sb_aws_eks.spec[0].template[0].metadata[0].labels.app
    }

    port {
      port        = 8080
      target_port = 8080
    }

    type = "LoadBalancer"
  }
}

# resource "null_resource" "port_forward" {
#   provisioner "local-exec" {
#     command = <<EOF
#            kubectl port-forward service/my-service 8080:80 &
#            echo "Port forwarding established"
#          EOF
#     # environment = {
#     #   KUBECONFIG = "/path/to/your/kubeconfig"  # Optional, if not using default
#     # }
#   }
# }
#
# resource "null_resource" "stop_port_forward" {
#   depends_on = [null_resource.port_forward]
#   provisioner "local-exec" {
#     command = "killall kubectl" # Or more specific process killing
#   }
# }

output "eks_cluster_name" {
  depends_on = [module.eks]
  value = module.eks.cluster_name
}

#Output Load Balancer IP to access from browser
output "nginx_load_balancer_ip" {
  depends_on = [kubernetes_service.sb_aws_eks]
  value = kubernetes_service.sb_aws_eks.status[0].load_balancer[0].ingress[0].ip
}

output "nginx_load_balancer_hostname" {
  depends_on = [kubernetes_service.sb_aws_eks]
  value = kubernetes_service.sb_aws_eks.status[0].load_balancer[0].ingress[0].hostname
}

output "eks_connect" {
  depends_on = [module.eks]
  value = "aws --profile brr-np-admin eks --region ${data.aws_region.current.name} update-kubeconfig --name ${module.eks.cluster_name}"
}
